// First, clear any existing data (optional)
MATCH (n) DETACH DELETE n;

// Create constraints and indexes (REQUIRED - run first!)
CREATE CONSTRAINT student_id IF NOT EXISTS FOR (s:Student) REQUIRE s.id IS UNIQUE;
CREATE CONSTRAINT course_id IF NOT EXISTS FOR (c:Course) REQUIRE c.id IS UNIQUE;
CREATE CONSTRAINT faculty_id IF NOT EXISTS FOR (f:Faculty) REQUIRE f.id IS UNIQUE;
CREATE CONSTRAINT degree_id IF NOT EXISTS FOR (d:Degree) REQUIRE d.id IS UNIQUE;
CREATE CONSTRAINT requirement_id IF NOT EXISTS FOR (r:RequirementGroup) REQUIRE r.id IS UNIQUE;
CREATE CONSTRAINT term_id IF NOT EXISTS FOR (t:Term) REQUIRE t.id IS UNIQUE;
CREATE CONSTRAINT textbook_id IF NOT EXISTS FOR (tb:Textbook) REQUIRE tb.id IS UNIQUE;

// Create indexes for better query performance
CREATE INDEX student_learning_style IF NOT EXISTS FOR (s:Student) ON (s.learningStyle);
CREATE INDEX course_department IF NOT EXISTS FOR (c:Course) ON (c.department);
CREATE INDEX course_level IF NOT EXISTS FOR (c:Course) ON (c.level);
CREATE INDEX term_type IF NOT EXISTS FOR (t:Term) ON (t.type);


// Students
LOAD CSV WITH HEADERS FROM 'file:///students.csv' AS row
CALL (row) {
  WITH row
  CREATE (:Student {
    id: row.`id:ID(Student)`,
    name: row.name,
    enrollmentDate: date(row.enrollmentDate),
    expectedGraduation: date(row.expectedGraduation),
    learningStyle: row.learningStyle,
    preferredCourseLoad: toInteger(row.`preferredCourseLoad:int`),
    preferredPace: row.preferredPace,
    workHoursPerWeek: CASE 
      WHEN row.`workHoursPerWeek:int` IS NULL OR row.`workHoursPerWeek:int` = '' 
      THEN NULL 
      ELSE toInteger(row.`workHoursPerWeek:int`) 
    END,
    financialAidStatus: row.financialAidStatus,
    preferredInstructionMode: row.preferredInstructionMode
  })
} IN TRANSACTIONS OF 1000 ROWS;

// Faculty
LOAD CSV WITH HEADERS FROM 'file:///faculty.csv' AS row
CALL (row) {
  WITH row
  CREATE (:Faculty {
    id: row.`id:ID(Faculty)`,
    name: row.name,
    department: row.department,
    // Accept either a JSON-ish array in the CSV or a pipe-delimited list
    teachingStyle: CASE 
      WHEN row.teachingStyle STARTS WITH '[' THEN apoc.convert.fromJsonList(row.teachingStyle)
      ELSE CASE WHEN row.teachingStyle IS NULL OR row.teachingStyle = '' THEN [] ELSE split(row.teachingStyle,'|') END
    END,
    avgRating: row.`avgRating:float`
  })
} IN TRANSACTIONS OF 1000 ROWS;

// Courses
LOAD CSV WITH HEADERS FROM 'file:///courses.csv' AS row
CALL (row) {
  WITH row
  CREATE (:Course {
    id: row.`id:ID(Course)`,
    name: row.name,
    department: row.department,
    credits: CASE WHEN row.`credits:int` IS NULL OR row.`credits:int` = '' THEN NULL ELSE toInteger(row.credits) END,
    level:   CASE WHEN row.`level:int`   IS NULL OR row.`level:int`   = '' THEN NULL ELSE toInteger(row.`level:int`)   END,
    avgDifficulty: CASE WHEN row.`avgDifficulty:float` IS NULL OR row.`avgDifficulty:float` = '' THEN NULL ELSE toInteger(row.`avgDifficulty:float`) END,
    avgTimeCommitment: CASE WHEN row.`avgTimeCommitment:int` IS NULL OR row.`avgTimeCommitment:int` = '' THEN NULL ELSE toInteger(row.`avgTimeCommitment:int`) END,
    termAvailability: CASE 
      WHEN row.termAvailability STARTS WITH '[' THEN apoc.convert.fromJsonList(row.termAvailability)
      ELSE CASE WHEN row.termAvailability IS NULL OR row.termAvailability = '' THEN [] ELSE split(row.termAvailability,'|') END
    END,
    instructionModes: CASE 
      WHEN row.instructionModes STARTS WITH '[' THEN apoc.convert.fromJsonList(row.instructionModes)
      ELSE CASE WHEN row.instructionModes IS NULL OR row.instructionModes = '' THEN [] ELSE split(row.instructionModes,'|') END
    END,
    tags: CASE 
      WHEN row.tags STARTS WITH '[' THEN apoc.convert.fromJsonList(row.tags)
      ELSE CASE WHEN row.tags IS NULL OR row.tags = '' THEN [] ELSE split(row.tags,'|') END
    END,
    visualLearnerSuccess:   CASE WHEN row.`visualLearnerSuccess:float`   IS NULL OR row.`visualLearnerSuccess:float`   = '' THEN NULL ELSE toFloat(row.`visualLearnerSuccess:float`)   END,
    auditoryLearnerSuccess: CASE WHEN row.`auditoryLearnerSuccess:float` IS NULL OR row.`auditoryLearnerSuccess:float` = '' THEN NULL ELSE toFloat(row.`auditoryLearnerSuccess:float`) END,
    kinestheticLearnerSuccess: CASE WHEN row.`kinestheticLearnerSuccess:float` IS NULL OR row.`kinestheticLearnerSuccess:float` = '' THEN NULL ELSE toFloat(row.`kinestheticLearnerSuccess:float`) END,
    readingLearnerSuccess:  CASE WHEN row.`readingLearnerSuccess:float`  IS NULL OR row.`readingLearnerSuccess:float`  = '' THEN NULL ELSE toFloat(row.`readingLearnerSuccess:float`)  END
  })
} IN TRANSACTIONS OF 1000 ROWS;

// Terms
LOAD CSV WITH HEADERS FROM 'file:///terms.csv' AS row
CALL (row) {
  WITH row
  CREATE (:Term {
    id: row.`id:ID(Term)`,
    name: row.name,
    startDate: date(row.startDate),
    endDate: date(row.endDate),
    type: row.type
  })
} IN TRANSACTIONS OF 1000 ROWS;

// Degrees
LOAD CSV WITH HEADERS FROM 'file:///degrees.csv' AS row
CALL (row) {
  WITH row
  CREATE (:Degree {
    id: row.`id:ID(Degree)`,
    name: row.name,
    department: row.department,
    type: row.type,
    totalCreditsRequired: row.`totalCreditsRequired:int`,
    coreCreditsRequired: row.`coreCreditsRequired:int`,
    electiveCreditsRequired: row.`electiveCreditsRequired:int`
  })
} IN TRANSACTIONS OF 1000 ROWS;

// Requirement Groups
LOAD CSV WITH HEADERS FROM 'file:///requirement_groups.csv' AS row
CALL (row) {
  WITH row
  CREATE (:RequirementGroup {
    id: row.`id:ID(RequirementGroup)`,
    name: row.name,
    minCredits: row.`minimumCourses:int`,
    minimumCredits: row.`minimumCredits:int`
  })
} IN TRANSACTIONS OF 1000 ROWS;


// Textbooks
LOAD CSV WITH HEADERS FROM 'file:///textbooks.csv' AS row
CALL (row) {
  WITH row
  CREATE (:Textbook {
    id: row.id, //this one breaks the constraints TODO!!!!
    name: row.name,
    publisher: row.publisher,
    price: row.`price:float`,
    page: row.`pages:int`,
    edition: row.`edition:int`,
    publicationYear: row.`publicationYear:int`,    
    isbn: row.isbn,
    category: row.category
  })
} IN TRANSACTIONS OF 1000 ROWS;



// Student → Degree (`student_degree.csv`)

LOAD CSV WITH HEADERS FROM 'file:///student_degree.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Student)`) AS sid,
       trim(row.`:END_ID(Degree)`)    AS did
  WHERE sid <> '' AND did <> ''
  MATCH (s:Student {id: sid})
  MATCH (d:Degree  {id: did})
  CREATE (s)-[:PURSUING]->(d)
} IN TRANSACTIONS OF 1000 ROWS;

// Faculty → Course (`teaching.csv`)

LOAD CSV WITH HEADERS FROM 'file:///teaching.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Faculty)`) AS fid,
       trim(row.`:END_ID(Course)`)    AS cid
  WHERE fid <> '' AND cid <> ''
  MATCH (f:Faculty {id: fid})
  MATCH (c:Course  {id: cid})
  CREATE (f)-[:TEACHES]->(c)
} IN TRANSACTIONS OF 1000 ROWS;


// Student → Course (completed) (`completed_courses.csv`)


LOAD CSV WITH HEADERS FROM 'file:///completed_courses.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Student)`) AS sid,
       trim(row.`:END_ID(Course)`)    AS cid,
       row.grade                      AS grade,
       toFloatOrNull(row.difficulty)  AS diff
  WHERE sid <> '' AND cid <> ''
  MATCH (s:Student {id: sid})
  MATCH (c:Course  {id: cid})
  CREATE (s)-[:COMPLETED {grade: grade, difficulty: diff}]->(c)
} IN TRANSACTIONS OF 1000 ROWS;


// Student → Course (enrolled) (`enrolled_courses.csv`)


LOAD CSV WITH HEADERS FROM 'file:///enrolled_courses.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Student)`) AS sid,
       trim(row.`:END_ID(Course)`)    AS cid,
       trim(coalesce(row.termId, row.term_id, '')) AS termId,
       coalesce(row.status, row.enrollment_status) AS status
  WHERE sid <> '' AND cid <> ''
  MATCH (s:Student {id: sid})
  MATCH (c:Course  {id: cid})
  CREATE (s)-[:ENROLLED_IN {term: termId, status: status}]->(c)
} IN TRANSACTIONS OF 1000 ROWS;


// Course ↔ Course (prerequisites) (`prerequisites.csv`)


LOAD CSV WITH HEADERS FROM 'file:///prerequisites.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Course)`) AS prereqId,
       trim(row.`:END_ID(Course)`)   AS courseId
  WHERE prereqId <> '' AND courseId <> ''
  MATCH (p:Course {id: prereqId})
  MATCH (c:Course {id: courseId})
  CREATE (p)-[:PREREQUISITE_FOR]->(c)
} IN TRANSACTIONS OF 1000 ROWS;


// Course → Course (leads_to) (`leads_to.csv`)


LOAD CSV WITH HEADERS FROM 'file:///leads_to.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Course)`) AS fromId,
       trim(row.`:END_ID(Course)`)   AS toId
  WHERE fromId <> '' AND toId <> ''
  MATCH (a:Course {id: fromId})
  MATCH (b:Course {id: toId})
  CREATE (a)-[:LEADS_TO]->(b)
} IN TRANSACTIONS OF 1000 ROWS;


// Course similarity (content) (`course_similarity_content.csv`)


LOAD CSV WITH HEADERS FROM 'file:///course_similarity_content.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Course)`) AS c1,
       trim(row.`:END_ID(Course)`)   AS c2,
       toFloatOrNull(row.score)      AS score
  WHERE c1 <> '' AND c2 <> ''
  MATCH (a:Course {id: c1})
  MATCH (b:Course {id: c2})
  CREATE (a)-[:SIMILAR_CONTENT {score: score}]->(b)
} IN TRANSACTIONS OF 1000 ROWS;


// Course similarity (difficulty) (`course_similarity_difficulty.csv`)


LOAD CSV WITH HEADERS FROM 'file:///course_similarity_difficulty.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Course)`) AS c1,
       trim(row.`:END_ID(Course)`)   AS c2,
       toFloatOrNull(row.score)      AS score
  WHERE c1 <> '' AND c2 <> ''
  MATCH (a:Course {id: c1})
  MATCH (b:Course {id: c2})
  CREATE (a)-[:SIMILAR_DIFFICULTY {score: score}]->(b)
} IN TRANSACTIONS OF 1000 ROWS;


// Student ↔ Student (learning style) (`learning_style_similarity.csv`)


LOAD CSV WITH HEADERS FROM 'file:///learning_style_similarity.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Student)`) AS s1,
       trim(row.`:END_ID(Student)`)   AS s2,
       toFloatOrNull(row.score)       AS score
  WHERE s1 <> '' AND s2 <> ''
  MATCH (a:Student {id: s1})
  MATCH (b:Student {id: s2})
  CREATE (a)-[:SIMILAR_STYLE {score: score}]->(b)
} IN TRANSACTIONS OF 1000 ROWS;


// Degree ↔ RequirementGroup (`requirement_groups.csv`)

LOAD CSV WITH HEADERS FROM 'file:///requirement_groups.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Degree)`)         AS did,
       trim(row.`:END_ID(RequirementGroup)`) AS rgid
  WHERE did <> '' AND rgid <> ''
  MATCH (d:Degree {id: did})
  MATCH (g:RequirementGroup {id: rgid})
  CREATE (d)-[:HAS_REQUIREMENT]->(g)
} IN TRANSACTIONS OF 1000 ROWS;

LOAD CSV WITH HEADERS FROM 'file:///course_requirement.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Course)`)         AS cid,
       trim(row.`:END_ID(RequirementGroup)`) AS rgid
  WHERE cid <> '' AND rgid <> ''
  MATCH (c:Course {id: cid})
  MATCH (g:RequirementGroup {id: rgid})
  CREATE (c)-[:SATISFIES]->(g)
} IN TRANSACTIONS OF 1000 ROWS;

// Verify
MATCH (:Course)-[r:SATISFIES]->(:RequirementGroup) RETURN count(r);


// 3) course_term.csv

//# Loader (Course)–[:OFFERED_IN {…}]→(Term)


LOAD CSV WITH HEADERS FROM 'file:///course_term.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Course)`) AS cid,
       trim(row.`:END_ID(Term)`)     AS tid,
       coalesce(row.section, row.`section:string`) AS section,
       toIntegerOrNull(coalesce(row.capacity, row.`capacity:int`)) AS capacity
  WHERE cid <> '' AND tid <> ''
  MATCH (c:Course {id: cid})
  MATCH (t:Term   {id: tid})
  CREATE (c)-[:OFFERED_IN {section: section, capacity: capacity}]->(t)
} IN TRANSACTIONS OF 1000 ROWS;

// Verify
MATCH (:Course)-[r:OFFERED_IN]->(:Term) RETURN count(r);



// performance_similarity.csv
// Loader (Student)–[:PERFORMANCE_SIMILARITY {score}]→(Student)


LOAD CSV WITH HEADERS FROM 'file:///performance_similarity.csv' AS row
CALL (row) {
  WITH trim(row.`:START_ID(Student)`) AS s1,
       trim(row.`:END_ID(Student)`)   AS s2,
       toFloatOrNull(coalesce(row.score, row.similarity, row.weight)) AS score
  WHERE s1 <> '' AND s2 <> ''
  MATCH (a:Student {id: s1})
  MATCH (b:Student {id: s2})
  CREATE (a)-[:PERFORMANCE_SIMILARITY {score: score}]->(b)
} IN TRANSACTIONS OF 1000 ROWS;

// Verify
MATCH (:Student)-[r:PERFORMANCE_SIMILARITY]->(:Student) RETURN count(r);

LOAD CSV WITH HEADERS FROM 'file:///requirement_degree.csv' AS row
CALL (row) {
  WITH trim(row.:START_ID(RequirementGroup)) AS rgid,
       trim(row.:END_ID(Degree))            AS did
  WHERE rgid <> '' AND did <> ''
  MATCH (g:RequirementGroup {id: rgid})
  MATCH (d:Degree           {id: did})
  CREATE (g)-[:PART_OF]->(d)
} IN TRANSACTIONS OF 1000 ROWS;

// Check
MATCH (:RequirementGroup)-[r:PART_OF]->(:Degree) RETURN count(r);
LOAD CSV WITH HEADERS FROM 'file:///course_textbooks.csv' AS row
WITH trim(row.:START_ID(Course))  AS cid,
     trim(row.:END_ID(Textbook))  AS tbid,
     row.:TYPE                    AS t,
     toIntegerOrNull(row.recommendedOrder:int) AS ord,
     toLower(coalesce(row.isRequired:boolean,'')) AS reqStr
WHERE cid <> '' AND tbid <> ''
MATCH (c:Course   {id: cid})
MATCH (b:Textbook {id: tbid})
FOREACH ( IN CASE WHEN t='REQUIRES'   THEN [1] ELSE [] END |
  CREATE (c)-[:REQUIRES   {isRequired: true,  recommendedOrder: ord}]->(b))
FOREACH ( IN CASE WHEN t='RECOMMENDS' THEN [1] ELSE [] END |
  CREATE (c)-[:RECOMMENDS {isRequired: CASE WHEN reqStr IN ['true','1','yes','y'] THEN true
                                            WHEN reqStr IN ['false','0','no','n'] THEN false
                                            ELSE NULL END,
                           recommendedOrder: ord}]->(b));

// Check
MATCH (:Course)-[r:REQUIRES]->(:Textbook) RETURN count(r);
MATCH (:Course)-[r:RECOMMENDS]->(:Textbook) RETURN count(r);
LOAD CSV WITH HEADERS FROM 'file:///page_views.csv' AS row
CALL (row) {
  WITH trim(row.:START_ID(Student)) AS sid,
       trim(row.:END_ID(Textbook))  AS tbid,
       row.courseId                   AS courseId,
       toIntegerOrNull(row.pageNumber:int) AS pageNumber,
       row.timestamp                  AS ts,
       toIntegerOrNull(row.duration:int)   AS dur
  WHERE sid <> '' AND tbid <> ''
  MATCH (s:Student  {id: sid})
  MATCH (b:Textbook {id: tbid})
  CREATE (s)-[:VIEWED_PAGE {courseId: courseId, pageNumber: pageNumber, timestamp: ts, duration: dur}]->(b)
} IN TRANSACTIONS OF 1000 ROWS;

// Check
MATCH (:Student)-[r:VIEWED_PAGE]->(:Textbook) RETURN count(r);
LOAD CSV WITH HEADERS FROM 'file:///textbook_interactions.csv' AS row
CALL (row) {
  WITH trim(row.:START_ID(Student)) AS sid,
       trim(row.:END_ID(Textbook))  AS tbid,
       row.courseId                   AS courseId,
       row.interactionType            AS action,
       row.timestamp                  AS ts,
       toIntegerOrNull(row.duration:int) AS dur
  WHERE sid <> '' AND tbid <> ''
  MATCH (s:Student  {id: sid})
  MATCH (b:Textbook {id: tbid})
  CREATE (s)-[:INTERACTED_WITH {courseId: courseId, action: action, timestamp: ts, duration: dur}]->(b)
} IN TRANSACTIONS OF 1000 ROWS;

// Check
MATCH (:Student)-[r:INTERACTED_WITH]->(:Textbook) RETURN count(r);
